
# 1.4 字错率(WER/CER)
WER，Word error rate，词错率，但一般称为字错率，是语音识别领域的关键性评估指标，WER越低表示效果越好！

CER，Character Error Rate，字符错误率，中文一般用CER来表示字错率，原因请见1.4.3。

## 1.4.1 、计算原理

### 1.4.1.1.编辑距离  (**levenshtein_distance.py**)

&emsp;&emsp;&emsp;Levenshtein距离，用于计算两个字符串之间的编辑距离。编辑距离的一种。是指两个字符串之间，由一个转换成另一个所需的最少编辑操作次数。算法概念是俄罗斯科学家弗拉基米尔·莱文斯坦（Levenshtein · Vladimir I）于1965年提出。允许的编辑操作包括：替换、插入、删除。


### 1.4.1.2.字符串编辑距离（Levenshtein距离）算法

#### 1.4.1.2.2.1算法实现

1.设定dp数组意义

&emsp;&emsp;dp[i][j]代表的意思为：以i - 1为结尾的字符串w1和以j - 1为结尾的字符串w2，最近的编辑距离记为dp[i][j]。

2.推导过程

&emsp;&emsp;比较w1在i - 1位置和w2在j - 1位置的字符，分为两种情况。

(1)不等

- 插入

例如w1 = "ab", w2 = "bca"。

&emsp;&emsp;若在w1上加字符：为了使使w[i - 1]与w2[j - 1]字符相等，那么就需要在w1的i - 1位置插入一个"b"，w1的长度增加1。也就是说此时以i-2为结尾的w1和以j-1位结尾的w2的最近编辑距离增加了一个插入操作。

即 $dp[i][j]= dp[i - 1][j] + 1$;

&emsp;&emsp;若在w2上加字符：使w[i - 1]与w2[j - 1]相同，那么就需要在w2的j - 1位置插入一个"a"，w2的长度增加1。也就是说此时以i - i为结尾的w1和以j - 2位结尾的w1的最近编辑距离增加了一个插入操作。
即 $dp[i][j]= dp[i][j - 1] + 1$;

- 替换

&emsp;&emsp;w1替换$w1[i - 1]$，使其与$word2[j - 1]$相同，那么以下标i - 2为结尾的w1与i - 2为结尾的w2的最近编辑距离加一个替换字符的操作。
即 $dp[i][j] = dp[i - 1][j - 1] + 1;$

- 删除

&emsp;&emsp;删除与插入其实所需要的操作数是一样的。在w1上删除一个字符，等同于在w2上插入一个字符的操作数。

&emsp;&emsp;以上三种操作，取最少编辑距离即：$dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;$

(2)相等

&emsp;&emsp;若w1[i - 1] == w2[j - 1]，无需编辑。即 dp[i][j] = dp[i - 1][j - 1];

&emsp;&emsp;通过以上两种情况，可推导出动态转移方程：
$$dp[i][j]=\begin{cases}
dp[i-1][j-1] & word1[i]=word2[j] \\
min(dp[i-1][j-1], dp[i-1][j-1], dp[i-1][j-1]) + 1 &
word1[i]≠word2[j] 
\end{cases}$$

#### 1.4.1.2.2.2例子：

1.空字符串经过几次变换成空、空a、空ap、...
|   |   | a | p | p | l | e |
|---|---|---|---|---|---|---|
|   | 0 | 1 | 2 | 3 | 4 | 5 |
| o | 
| p | 
| p | 
| a | 

2.空、空a、空ap、空app、空appa经过几次变成空字符串

|   |   | a | p | p | l | e |
|---|---|---|---|---|---|---|
|   | 0 | 1 | 2 | 3 | 4 | 5 |
| o | 1 | 
| p | 2 | 
| p | 3 |
| a | 4 |

3.o经过几次变换变成a(首先判断o、a不同，从他左、上、左上找最小值加1)
|   |   | a | p | p | l | e |
|---|---|---|---|---|---|---|
|   | 0 | 1 | 2 | 3 | 4 | 5 |
| o | 1 | 1
| p | 2 | 
| p | 3 |
| a | 4 |

4.o经过几次变换变成ap(首先判断o、p不同，从他左、上、左上找最小值加1)。o经过几次变换变成app、appl、apple易。
|   |   | a | p | p | l | e |
|---|---|---|---|---|---|---|
|   | 0 | **1** | **2** | 3 | 4 | 5 |
| o | 1 | **1** | 2 | 3 | 4 | 5 |
| p | 2 | 
| p | 3 |
| a | 4 |

4.op经过几次变换变成a(首先判断a、p不同，从他左、上、左上找最小值加1)。左上加1是p更新a操作，上加1是删除p
|   |   | a | p | p | l | e |
|---|---|---|---|---|---|---|
|   | 0 | 1 | 2 | 3 | 4 | 5 |
| o | 1 | 1 | 2 | 3 | 4 | 5 |
| p | 2 | 2 |
| p | 3 |
| a | 4 |

4.op经过几次变换变成ap(首先判断p、p相同，copy左上的值)。o经过多少步已经变成a，p与p一样，就不用编辑。
|   |   | a | p | p | l | e |
|---|---|---|---|---|---|---|
|   | 0 | 1 | 2 | 3 | 4 | 5 |
| o | 1 | 1 | 2 | 3 | 4 | 5 |
| p | 2 | 2 | 1 |
| p | 3 |
| a | 4 |

.... ....

|   |   | a | p | p | l | e |
|---|---|---|---|---|---|---|
|   | 0 | 1 | 2 | 3 | 4 | 5 |
| o | 1 | 1 | 2 | 3 | 4 | 5 |
| p | 2 | 2 | 1 | 2 | 3 | 4 |
| p | 3 | 3 | 2 | 1 | 2 | 3 |
| a | 4 | 3 | 3 | 2 | 2 | 3 |

## 1.4.2、计算公式(重要)

$$ WER = (S + D + I ) / N = (S + D + I ) / (S + D + H ) $$

**注**：其可以表示成最小编辑距离除以ref的长度

&emsp;&emsp;WER(word error rate)经常作为语音识别ASR任务的性能评测指标，WER的计算公式，直接从网上粘贴过来了。

- S 为替换的字数，常用缩写WS
- D 为删除的字数，常用缩写WD
- I  为插入的字数，常用缩写WI
- H 为正确的字数，维基百科是C，但我统一改用H
- N 为（S替换+ D删除+ H正确）的字数 / ref的字数

Findyou：

1.正确的字数：维基百科里用的是C代表，$ H = N - (S+D) = C $，我这边直接改成H，减少过多概念与变量。

2.大多数文章都没有给出N的计算方式，很容易误以为是原句总字数或者识别结果总字数。

3.不理解没关系，下面实例会帮助理解。

## 1.4.3、 问题
- 问题1：为什么WER会大于100%

因为有插入字(识别多出来的字)，所以理论上WER有可能大于100%，在下面实例我会举例（请见2.3.5），但实际场景，特别是大样本量的时候，基本太不可能出现。

- 问题2：说中文应该用CER，即“字符错误率”（Character Error Rate）
Findyou举个栗子：

英文：hello   # 算一个Word
中文：你好     # 算两个字符
啰嗦文字解释，就是：

英文，因为最小单元是Word，语音识别应该用"字错误率"（WER），

中文，因为最小单元是字符，语音识别应该用“字符错误率”（CER）。

BUT(就是但是的意思...)，他跟我前面那一句一样，说的都是废话！

我们计算的时候谁不是按：中文的一个字符  = 英文的一个Word，那这样用WER的公式有什么问题呢？

谁再跟你咬文嚼字，怼他，使劲怼！

怼完，说回严谨的话，建议采用CER表示，哈哈哈哈哈......

# 1.5、字正确率(W.Corr）
字正确率，Word Correct，一般国内宣传用的多，识别率(识别正确率)达到多少多少(请见1.7)。
- 计算公式
$$ W.Corr =   ( N - D - S ) / N = H / N $$
- 问题：只计算了识别正确的字，没有管多出来的字（I插入），当然一般情况下不会有什么问题。

# 1.6、字准确率(W.Acc）
字准确率，Word Accuracy

- 计算公式

$$ W.Acc =  1 - WER = ( N - D - S - I ) / N = (H - I) / N $$

语音识别ASR - HTK(HResults)计算字错率WER、句错率SER-LMLPHP

- 特殊情况：当 I=0 时， W.Acc = W.Corr
- 问题：为什么W.Acc会是负数？

同WER，因为有插入字。换个说法，因为字准确率=1 - WER，而WER可能大于1，所以W.Acc会出现负数，但实际情况基本不存在。

# python cer 字错率计算
```
 def cer(r: list, h: list):
     """
     Calculation of CER with Levenshtein distance.
     """
     # initialisation
     import numpy
     d = numpy.zeros((len(r) + 1) * (len(h) + 1), dtype=numpy.uint16)
     d = d.reshape((len(r) + 1, len(h) + 1))
     for i in range(len(r) + 1):
         for j in range(len(h) + 1):
             if i == 0:
                 d[0][j] = j
             elif j == 0:
                 d[i][0] = i
 ​
     # computation
     for i in range(1, len(r) + 1):
         for j in range(1, len(h) + 1):
             if r[i - 1] == h[j - 1]:
                 d[i][j] = d[i - 1][j - 1]
             else:
                 substitution = d[i - 1][j - 1] + 1
                 insertion = d[i][j - 1] + 1
                 deletion = d[i - 1][j] + 1
                 d[i][j] = min(substitution, insertion, deletion)
 ​
     return d[len(r)][len(h)] / float(len(r))
 ​
 ​
 if __name__ == "__main__":
     r = '从卡耐基梅隆大学几代研发人员开始，本文对过去40年人们从语音识别技术进步所获得的启示进行了探讨。'
     h = '从卡耐基梅隆大学几代研发人员开始，对过去40年人们从ASR技术进步所获得的启示进行了深入探讨。'
     r = [x for x in r]
     h = [x for x in h]
 ​
     r = '北 京 成 交 已 实 现 无 人 运 行'
     h = '<UNK> 金 冲 压 已 实 现 无 人 运 行'
     r = r.split()
     h = h.split()
    
     print(cer(r, h))

```






